
same code generated for "eax", "ebx", "ecx", "es"
set_seg_reg isn't call anywhere
segment_register_operand might not be well used

LOOK FOR: "Simple-Constraints" in the internals manual with Iopi

-----------------------
BETTER: now the function with our mov is created (before sengment_operand was binded on movsi_1 (or something like that))
-----------------------

OK i386.c: x86_order_regs_for_local_alloc
OK i386.md: define_insn "set_seg_reg"
MAYBE i386.md: add UNSPEC_* for seg_regs
OK/MAYBE predicates.md: (define_predicate "segment_register_operand"
OK i386.h: #define FIRST_PSEUDO_REGISTER 59
OK i386.h: set seg regiters ids (CODE_SEG_REGNUM to LAST_ALT_DATA_SEG_REG)
OK recog.c: nonimmediate_operand and nonmemory_operand (no change)

PRETTY SURE: warning coming form crtfastmath.c aren't from here


-----------------------------------
in "(insn a b c d" it seems that :
a = current_rtx + 1
b = current_rtx
c = current_rtx + 2
----->>> this might depend of the insn ...x
--------------------------------------

gcc/recog.c
    /* A register whose class is NO_REGS is not a general operand.  */

gcc/rtl.h
If this assembler code template starts with a * then it is a fragment of
      C code to run to decide on a template to use.  Otherwise, it is the
      template to use.

/* Common union for an element of an rtx.  */

union rtunion_def
{
  int rt_int;
  unsigned int rt_uint;
  const char *rt_str;
  rtx rt_rtx;	-	-	-	-	<<<------
  rtvec rt_rtvec;
  enum machine_mode rt_type;
  addr_diff_vec_flags rt_addr_diff_vec_flags;
  struct cselib_val_struct *rt_cselib;
  struct bitmap_head_def *rt_bit;
  tree rt_tree;
  struct basic_block_def *rt_bb;
  mem_attrs *rt_mem;
  reg_attrs *rt_reg;
};

#ifdef ENABLE_RTL_CHECKING
  #define RTL_CHECK2(RTX, N, C1, C2) __extension__			\
(*({ rtx const _rtx = (RTX); const int _n = (N);			\
     const enum rtx_code _code = GET_CODE (_rtx);			\
     if (_n < 0 || _n >= GET_RTX_LENGTH (_code))			\
       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,		\
				__FUNCTION__);				\
     if (GET_RTX_FORMAT(_code)[_n] != C1				\
	 && GET_RTX_FORMAT(_code)[_n] != C2)				\
       rtl_check_failed_type2 (_rtx, _n, C1, C2, __FILE__, __LINE__,	\
			       __FUNCTION__);				\
     &_rtx->u.fld[_n]; }))

#else
  #define RTL_CHECK2(RTX, N, C1, C2)  ((RTX)->u.fld[N])
#endif

#define XEXP(RTX, N)  (RTL_CHECK2 (RTX, N, 'e', 'u').rt_rtx)
#define XSTR(RTX, N)	(RTL_CHECK2 (RTX, N, 's', 'S').rt_str)

===>> XEXP(RTX, N)    (((RTX)->u.fld[N]).rt_rtx)


-----------------------------------------------------------------

http://www.cygwin.com/ml/gdb-patches/2004-04/msg00025.html

> Notice that gcc regno 6 (ebp) and 7 (esp) map to regno 4 and 5
> respectively in the "default" (aka dbx, stabs, sdb) table.  But, in
> the svr4 (aka dwarf, dwarf2, stabs-in-elf) table, they map to regno 5 and
> 4 respectively.
------------------------------------------------------------------

fixed_register
called_use_register

 10.8.1 Basic Characteristics of Registers
http://www.delorie.com/gnu/docs/gcc/gccint_115.html
FIXED_REGISTERS
    An initializer that says which registers are used for fixed purposes all throughout the compiled code and are therefore not available for general allocation. These would include the stack pointer, the frame pointer (except on machines where that can be used as a general register when no frame pointer is needed), the program counter on machines where that is considered one of the addressable registers, and any other numbered register with a standard use.

    This information is expressed as a sequence of numbers, separated by commas and surrounded by braces. The nth number is 1 if register n is fixed, 0 otherwise.

    The table initialized from this macro, and the table initialized by the following one, may be overridden at run time either automatically, by the actions of the macro CONDITIONAL_REGISTER_USAGE, or by the user with the command options `-ffixed-reg', `-fcall-used-reg' and `-fcall-saved-reg'.

CALL_USED_REGISTERS
    Like FIXED_REGISTERS but has 1 for each register that is clobbered (in general) by function calls as well as for fixed registers. This macro therefore identifies the registers that are not available for general allocation of values that must live across function calls.

    If a register has 0 in CALL_USED_REGISTERS, the compiler automatically saves it on function entry and restores it on function exit, if the register is used within the function.


-----------------------------------

11.8 Registers and Memory

All the machine registers that can be used for storage of data are
given hard register numbers, even those that can be used only in
certain instructions or can hold only certain types of data.

A hard register may be accessed in various modes throughout one
function, but each pseudo register is given a natural mode and is
accessed only in that mode. When it is necessary to describe an access
to a pseudo register using a nonnatural mode, a subreg expression is
used.

A reg expression with a machine mode that specifies more than one word
of data may actually stand for several consecutive registers. If in
addition the register number specifies a hardware register, then it
actually represents several consecutive hardware registers starting
with the specified one.

Each pseudo register number used in a function's RTL code is
represented by a unique reg expression.

Some pseudo register numbers, those within the range of
FIRST_VIRTUAL_REGISTER to LAST_VIRTUAL_REGISTER only appear during the
RTL generation phase and are eliminated before the optimization
phases. These represent locations in the stack frame that cannot be
determined until RTL generation for the function has been completed.


--------------------------------------------------------------------
13.2 Everything about Instruction Patterns

A condition. This is a string which contains a C expression that is
the final test to decide whether an insn body matches this pattern.

For a named pattern, the condition (if present) may not depend on the
data in the insn being matched, but only the target-machine-type
flags. The compiler needs to test these conditions during
initialization in order to learn exactly which named instructions are
available in a particular run.

For nameless patterns, the condition is applied only when matching an
individual insn, and only after the insn has matched the pattern's
recognition template. The insn's operands may be found in the vector
operands. For an insn where the condition has once matched, it can't
be used to control register allocation, for example by excluding
certain hard registers or hard register combinations.
