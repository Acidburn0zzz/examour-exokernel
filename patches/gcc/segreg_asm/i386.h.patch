*** gcc-4.1.0/./gcc/config/i386/i386.h	2006-09-16 15:25:39.000000000 +0200
--- gcc-4.1.0-patch-segreg/./gcc/config/i386/i386.h	2006-09-23 15:31:27.000000000 +0200
*************** extern int x86_prefetch_sse;
*** 677,683 ****
     eliminated during reloading in favor of either the stack or frame
     pointer.  */
  
! #define FIRST_PSEUDO_REGISTER 53
  
  /* Number of hardware registers that go into the DWARF-2 unwind info.
     If not defined, equals FIRST_PSEUDO_REGISTER.  */
--- 677,683 ----
     eliminated during reloading in favor of either the stack or frame
     pointer.  */
  
! #define FIRST_PSEUDO_REGISTER 59
  
  /* Number of hardware registers that go into the DWARF-2 unwind info.
     If not defined, equals FIRST_PSEUDO_REGISTER.  */
*************** extern int x86_prefetch_sse;
*** 706,712 ****
  /*  r8,  r9, r10, r11, r12, r13, r14, r15*/			\
       2,   2,   2,   2,   2,   2,   2,   2,			\
  /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/		\
!      2,   2,    2,    2,    2,    2,    2,    2}
  
  
  /* 1 for registers not available across function calls.
--- 706,714 ----
  /*  r8,  r9, r10, r11, r12, r13, r14, r15*/			\
       2,   2,   2,   2,   2,   2,   2,   2,			\
  /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/		\
!      2,   2,    2,    2,    2,    2,    2,    2,		\
! /*  cs,ss,ds,es,fs,gs */					\
!      1, 1, 1, 1, 1, 1}
  
  
  /* 1 for registers not available across function calls.
*************** extern int x86_prefetch_sse;
*** 734,740 ****
  /*  r8,  r9, r10, r11, r12, r13, r14, r15*/			\
       1,   1,   1,   1,   2,   2,   2,   2,			\
  /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/		\
!      1,   1,    1,    1,    1,    1,    1,    1}		\
  
  /* Order in which to allocate registers.  Each register must be
     listed once, even those in FIXED_REGISTERS.  List frame pointer
--- 736,745 ----
  /*  r8,  r9, r10, r11, r12, r13, r14, r15*/			\
       1,   1,   1,   1,   2,   2,   2,   2,			\
  /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/		\
!      1,   1,    1,    1,    1,    1,    1,    1,		\
! /*  cs,ss,ds,es,fs,gs */					\
!      1, 1, 1, 1, 1, 1}
! 
  
  /* Order in which to allocate registers.  Each register must be
     listed once, even those in FIXED_REGISTERS.  List frame pointer
*************** extern int x86_prefetch_sse;
*** 749,755 ****
  {  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\
     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,	\
     33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  \
!    48, 49, 50, 51, 52 }
  
  /* ORDER_REGS_FOR_LOCAL_ALLOC is a macro which permits reg_alloc_order
     to be rearranged based on a particular function.  When using sse math,
--- 754,760 ----
  {  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\
     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,	\
     33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  \
!    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58 }
  
  /* ORDER_REGS_FOR_LOCAL_ALLOC is a macro which permits reg_alloc_order
     to be rearranged based on a particular function.  When using sse math,
*************** do {									\
*** 818,830 ****
     applied to them.
     */
  
! #define HARD_REGNO_NREGS(REGNO, MODE)   \
    (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)	\
     ? (COMPLEX_MODE_P (MODE) ? 2 : 1)					\
     : ((MODE) == XFmode							\
        ? (TARGET_64BIT ? 2 : 3)						\
        : (MODE) == XCmode						\
        ? (TARGET_64BIT ? 4 : 6)						\
        : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))
  
  #define VALID_SSE2_REG_MODE(MODE) \
--- 823,839 ----
     applied to them.
     */
  
! #define HARD_REGNO_NREGS(REGNO, MODE)					\
    (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)	\
     ? (COMPLEX_MODE_P (MODE) ? 2 : 1)					\
     : ((MODE) == XFmode							\
        ? (TARGET_64BIT ? 2 : 3)						\
        : (MODE) == XCmode						\
        ? (TARGET_64BIT ? 4 : 6)						\
+       : (CODE_SEG_REGNO_P(REGNO) || STACK_SEG_REGNO_P(REGNO))		\
+       ? 2								\
+       : (DATA_SEG_REGNO_P(REGNO) || ALT_DATA_SEG_REGNO_P(REGNO))	\
+       ? 2								\
        : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))
  
  #define VALID_SSE2_REG_MODE(MODE) \
*************** do {									\
*** 864,869 ****
--- 873,880 ----
     || (MODE) == V8HImode || (MODE) == V2DFmode || (MODE) == V2DImode	\
     || (MODE) == V4SFmode || (MODE) == V4SImode)
  
+ #define	VALID_SEG_REG_MODE_P(MODE)	((MODE) == HImode)
+ 
  /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */
  
  #define HARD_REGNO_MODE_OK(REGNO, MODE)	\
*************** do {									\
*** 927,932 ****
--- 938,957 ----
  #define FIRST_REX_SSE_REG  (LAST_REX_INT_REG + 1)
  #define LAST_REX_SSE_REG   (FIRST_REX_SSE_REG + 7)
  
+ /* Code segment register. */
+ #define	CODE_SEG_REGNUM		(LAST_REX_SSE_REG + 1)
+ 
+ /* Stack segment register. */
+ #define	STACK_SEG_REGNUM	(CODE_SEG_REGNUM + 1)
+ 
+ /* Default data segment registers. */
+ #define	FIRST_DATA_SEG_REG	(STACK_SEG_REGNUM + 1)
+ #define	LAST_DATA_SEG_REG	(FIRST_DATA_SEG_REG + 1)
+ 
+ /* Alternative data segment registers. */
+ #define	FIRST_ALT_DATA_SEG_REG	(LAST_DATA_SEG_REG + 1)
+ #define	LAST_ALT_DATA_SEG_REG	(FIRST_ALT_DATA_SEG_REG + 1)
+ 
  /* Value should be nonzero if functions must have frame pointers.
     Zero means the frame pointer need not be set up (and parms
     may be accessed via the stack pointer) in functions that seem suitable.
*************** enum reg_class
*** 1041,1046 ****
--- 1066,1076 ----
    FLOAT_INT_REGS,
    INT_SSE_REGS,
    FLOAT_INT_SSE_REGS,
+   CODE_SEG_REGS,		/* %cs */
+   STACK_SEG_REGS,		/* %ss */
+   DATA_SEG_REGS,		/* %ds, %es */
+   ALT_DATA_SEG_REGS,		/* %fs, %gs */
+   SEG_REGS,			/* %cs, %ss, %ds, %es, %fs, %gs */
    ALL_REGS, LIM_REG_CLASSES
  };
  
*************** enum reg_class
*** 1068,1120 ****
  
  /* Give names of register classes as strings for dump file.  */
  
! #define REG_CLASS_NAMES \
! {  "NO_REGS",				\
!    "AREG", "DREG", "CREG", "BREG",	\
!    "SIREG", "DIREG",			\
!    "AD_REGS",				\
!    "Q_REGS", "NON_Q_REGS",		\
!    "INDEX_REGS",			\
!    "LEGACY_REGS",			\
!    "GENERAL_REGS",			\
!    "FP_TOP_REG", "FP_SECOND_REG",	\
!    "FLOAT_REGS",			\
!    "SSE_REGS",				\
!    "MMX_REGS",				\
!    "FP_TOP_SSE_REGS",			\
!    "FP_SECOND_SSE_REGS",		\
!    "FLOAT_SSE_REGS",			\
!    "FLOAT_INT_REGS",			\
!    "INT_SSE_REGS",			\
!    "FLOAT_INT_SSE_REGS",		\
     "ALL_REGS" }
  
  /* Define which registers fit in which classes.
     This is an initializer for a vector of HARD_REG_SET
     of length N_REG_CLASSES.  */
  
! #define REG_CLASS_CONTENTS						\
! {     { 0x00,     0x0 },						\
!       { 0x01,     0x0 }, { 0x02, 0x0 },	/* AREG, DREG */		\
!       { 0x04,     0x0 }, { 0x08, 0x0 },	/* CREG, BREG */		\
!       { 0x10,     0x0 }, { 0x20, 0x0 },	/* SIREG, DIREG */		\
!       { 0x03,     0x0 },		/* AD_REGS */			\
!       { 0x0f,     0x0 },		/* Q_REGS */			\
!   { 0x1100f0,  0x1fe0 },		/* NON_Q_REGS */		\
!       { 0x7f,  0x1fe0 },		/* INDEX_REGS */		\
!   { 0x1100ff,  0x0 },			/* LEGACY_REGS */		\
!   { 0x1100ff,  0x1fe0 },		/* GENERAL_REGS */		\
!      { 0x100,     0x0 }, { 0x0200, 0x0 },/* FP_TOP_REG, FP_SECOND_REG */\
!     { 0xff00,     0x0 },		/* FLOAT_REGS */		\
! { 0x1fe00000,0x1fe000 },		/* SSE_REGS */			\
! { 0xe0000000,    0x1f },		/* MMX_REGS */			\
! { 0x1fe00100,0x1fe000 },		/* FP_TOP_SSE_REG */		\
! { 0x1fe00200,0x1fe000 },		/* FP_SECOND_SSE_REG */		\
! { 0x1fe0ff00,0x1fe000 },		/* FLOAT_SSE_REGS */		\
!    { 0x1ffff,  0x1fe0 },		/* FLOAT_INT_REGS */		\
! { 0x1fe100ff,0x1fffe0 },		/* INT_SSE_REGS */		\
! { 0x1fe1ffff,0x1fffe0 },		/* FLOAT_INT_SSE_REGS */	\
! { 0xffffffff,0x1fffff }							\
  }
  
  /* The same information, inverted:
--- 1098,1160 ----
  
  /* Give names of register classes as strings for dump file.  */
  
! #define REG_CLASS_NAMES				\
! {  "NO_REGS",					\
!    "AREG", "DREG", "CREG", "BREG",		\
!    "SIREG", "DIREG",				\
!    "AD_REGS",					\
!    "Q_REGS", "NON_Q_REGS",			\
!    "INDEX_REGS",				\
!    "LEGACY_REGS",				\
!    "GENERAL_REGS",				\
!    "FP_TOP_REG", "FP_SECOND_REG",		\
!    "FLOAT_REGS",				\
!    "SSE_REGS",					\
!    "MMX_REGS",					\
!    "FP_TOP_SSE_REGS",				\
!    "FP_SECOND_SSE_REGS",			\
!    "FLOAT_SSE_REGS",				\
!    "FLOAT_INT_REGS",				\
!    "INT_SSE_REGS",				\
!    "FLOAT_INT_SSE_REGS",			\
!    "CODE_SEG_REGS",				\
!    "STACK_SEG_REGS",				\
!    "DATA_SEG_REGS",				\
!    "ALT_DATA_SEG_REGS",				\
!    "SEG_REGS",					\
     "ALL_REGS" }
  
  /* Define which registers fit in which classes.
     This is an initializer for a vector of HARD_REG_SET
     of length N_REG_CLASSES.  */
  
! #define REG_CLASS_CONTENTS							\
! {     { 0x00,     0x0 },							\
!       { 0x01,     0x0 }, { 0x02, 0x0 },	/* AREG, DREG */			\
!       { 0x04,     0x0 }, { 0x08, 0x0 },	/* CREG, BREG */			\
!       { 0x10,     0x0 }, { 0x20, 0x0 },	/* SIREG, DIREG */			\
!       { 0x03,     0x0 },		/* AD_REGS */				\
!       { 0x0f,     0x0 },		/* Q_REGS */				\
!   { 0x1100f0,  0x1fe0 },		/* NON_Q_REGS */			\
!       { 0x7f,  0x1fe0 },		/* INDEX_REGS */			\
!   { 0x1100ff,  0x0 },			/* LEGACY_REGS */			\
!   { 0x1100ff,  0x1fe0 },		/* GENERAL_REGS */			\
!      { 0x100,     0x0 }, { 0x0200, 0x0 },/* FP_TOP_REG, FP_SECOND_REG */	\
!     { 0xff00,     0x0 },		/* FLOAT_REGS */			\
! { 0x1fe00000,0x1fe000 },		/* SSE_REGS */				\
! { 0xe0000000,    0x1f },		/* MMX_REGS */				\
! { 0x1fe00100,0x1fe000 },		/* FP_TOP_SSE_REG */			\
! { 0x1fe00200,0x1fe000 },		/* FP_SECOND_SSE_REG */			\
! { 0x1fe0ff00,0x1fe000 },		/* FLOAT_SSE_REGS */			\
!    { 0x1ffff,  0x1fe0 },		/* FLOAT_INT_REGS */			\
! { 0x1fe100ff,0x1fffe0 },		/* INT_SSE_REGS */			\
! { 0x1fe1ffff,0x1fffe0 },		/* FLOAT_INT_SSE_REGS */		\
! { 0xffffffff,0x1fffff },							\
!      { 0x0,  0x200000 },		/* CODE_SEG_REGS */			\
!      { 0x0,  0x400000 },		/* STACK_SEG_REGS */			\
!      { 0x0, 0x1800000 },		/* DATA_SEG_REGS */			\
!      { 0x0, 0x6000000 },		/* ALT_DATA_SEG_REGS */			\
!      { 0x0, 0x7E00000 }			/* SEG_REGS */				\
  }
  
  /* The same information, inverted:
*************** enum reg_class
*** 1181,1194 ****
  #define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))
  #define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)
  
  /* The class value for index registers, and the one for base regs.  */
  
  #define INDEX_REG_CLASS INDEX_REGS
  #define BASE_REG_CLASS GENERAL_REGS
  
  /* Unused letters:
!     B                 TU W   
!           h jk          vw  z
  */
  
  /* Get reg_class from a letter such as appears in the machine description.  */
--- 1221,1250 ----
  #define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))
  #define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)
  
+ #define	CODE_SEG_REGNO_P(N)	((N) == CODE_SEG_REGNUM)
+ 
+ #define	STACK_SEG_REGNO_P(N)	((N) == STACK_SEG_REGNUM)
+ 
+ #define	DATA_SEG_REGNO_P(N)					\
+ 	((N) >= FIRST_DATA_SEG_REG && (N) <= LAST_DATA_SEG_REG)
+ 
+ #define	ALT_DATA_SEG_REGNO_P(N)						\
+ 	((N) >= FIRST_ALT_DATA_SEG_REG && (N) <= LAST_ALT_DATA_SEG_REG)
+ 
+ #define	SEG_REGNO_P(N)	(CODE_SEG_REGNO_P(N) || STACK_SEG_REGNO_P(N)	\
+ 			 || DATA_SEG_REGNO_P(N) || ALT_DATA_SEG_REGNO_P(N))
+ 
+ #define SEG_REG_P(XOP) (SEG_REGNO_P(REGNO(XOP)))
+ 
  /* The class value for index registers, and the one for base regs.  */
  
  #define INDEX_REG_CLASS INDEX_REGS
  #define BASE_REG_CLASS GENERAL_REGS
  
+ 
  /* Unused letters:
!     B                 TU W
!           h jk          vw
  */
  
  /* Get reg_class from a letter such as appears in the machine description.  */
*************** enum reg_class
*** 1218,1223 ****
--- 1274,1280 ----
     (C) == 'D' ? DIREG :						\
     (C) == 'S' ? SIREG :						\
     (C) == 'l' ? INDEX_REGS :					\
+    (C) == 'z' ? SEG_REGS :					\
     NO_REGS)
  
  /* The letters I, J, K, L, M, N, and O in a register constraint string
*************** do {							\
*** 1958,1976 ****
   "xmm0","xmm1","xmm2","xmm3","xmm4","xmm5","xmm6","xmm7",		\
   "mm0", "mm1", "mm2", "mm3", "mm4", "mm5", "mm6", "mm7"	,		\
   "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",			\
!  "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15"}
  
  #define REGISTER_NAMES HI_REGISTER_NAMES
  
  /* Table of additional register names to use in user input.  */
  
! #define ADDITIONAL_REGISTER_NAMES \
  { { "eax", 0 }, { "edx", 1 }, { "ecx", 2 }, { "ebx", 3 },	\
    { "esi", 4 }, { "edi", 5 }, { "ebp", 6 }, { "esp", 7 },	\
    { "rax", 0 }, { "rdx", 1 }, { "rcx", 2 }, { "rbx", 3 },	\
    { "rsi", 4 }, { "rdi", 5 }, { "rbp", 6 }, { "rsp", 7 },	\
    { "al", 0 }, { "dl", 1 }, { "cl", 2 }, { "bl", 3 },		\
!   { "ah", 0 }, { "dh", 1 }, { "ch", 2 }, { "bh", 3 } }
  
  /* Note we are omitting these since currently I don't know how
  to get gcc to use these, since they want the same but different
--- 2015,2037 ----
   "xmm0","xmm1","xmm2","xmm3","xmm4","xmm5","xmm6","xmm7",		\
   "mm0", "mm1", "mm2", "mm3", "mm4", "mm5", "mm6", "mm7"	,		\
   "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",			\
!  "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15",	\
!  "cs", "ss", "ds", "es", "fs", "gs"}
  
  #define REGISTER_NAMES HI_REGISTER_NAMES
  
  /* Table of additional register names to use in user input.  */
  
! #define ADDITIONAL_REGISTER_NAMES				\
  { { "eax", 0 }, { "edx", 1 }, { "ecx", 2 }, { "ebx", 3 },	\
    { "esi", 4 }, { "edi", 5 }, { "ebp", 6 }, { "esp", 7 },	\
    { "rax", 0 }, { "rdx", 1 }, { "rcx", 2 }, { "rbx", 3 },	\
    { "rsi", 4 }, { "rdi", 5 }, { "rbp", 6 }, { "rsp", 7 },	\
    { "al", 0 }, { "dl", 1 }, { "cl", 2 }, { "bl", 3 },		\
!   { "ah", 0 }, { "dh", 1 }, { "ch", 2 }, { "bh", 3 },		\
!   { "cs", 53 }, { "ss", 54 }, { "ds", 55 }, { "es", 56 },	\
!   { "fs", 57 }, { "gs", 58 }					\
! }
  
  /* Note we are omitting these since currently I don't know how
  to get gcc to use these, since they want the same but different
*************** enum ix86_entity
*** 2195,2201 ****
    MAX_386_ENTITIES
  };
  
! enum ix86_stack_slot 
  {
    SLOT_TEMP = 0,
    SLOT_CW_STORED,
--- 2256,2262 ----
    MAX_386_ENTITIES
  };
  
! enum ix86_stack_slot
  {
    SLOT_TEMP = 0,
    SLOT_CW_STORED,
